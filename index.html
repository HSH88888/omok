<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Omok & Baduk</title>
    <style>
        :root {
            --bg-color: #e0e5ec;
            --text-color: #4a4a4a;
            --board-bg: #e3a05b;
            --accent-brown: #5d4037;
            --accent-orange: #ffcc80;
            --accent-blue: #e3f2fd;
            
            /* Neumorphism Shadows */
            --shadow-light: -9px -9px 16px rgba(255, 255, 255, 0.8);
            --shadow-dark: 9px 9px 16px rgba(163, 177, 198, 0.6);
            --inner-shadow: inset 6px 6px 10px 0 rgba(163, 177, 198, 0.7), 
                            inset -6px -6px 10px 0 rgba(255, 255, 255, 0.8);
            
            --grid-size: 5.2vw;
        }
        @media (min-width: 600px) { :root { --grid-size: 32px; } }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 20px 0;
            display: flex; flex-direction: column; align-items: center;
            background-color: var(--bg-color);
            font-family: 'Pretendard', -apple-system, sans-serif;
            color: var(--text-color);
            touch-action: manipulation;
        }

        /* --- ìƒë‹¨ íˆ´ë°” --- */
        .toolbar {
            width: 95%; max-width: 500px;
            padding: 10px 15px;
            border-radius: 50px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
            gap: 10px; margin-bottom: 20px;
        }

        .mode-switch {
            background: var(--bg-color);
            box-shadow: var(--inner-shadow);
            border-radius: 30px; padding: 4px; display: flex;
        }
        
        .mode-btn {
            border: none; background: transparent;
            padding: 8px 15px; border-radius: 25px;
            font-weight: bold; color: #888; cursor: pointer; transition: 0.3s;
            font-size: 0.85rem;
        }
        .mode-btn.active {
            background: var(--accent-brown); color: white;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        /* AI ìŠ¤ìœ„ì¹˜ (ìƒˆë¡œ ì¶”ê°€ë¨) */
        .ai-switch {
            display: flex; align-items: center; gap: 5px;
            font-size: 0.85rem; font-weight: bold;
            background: var(--bg-color); padding: 5px 10px; border-radius: 20px;
            box-shadow: 3px 3px 6px rgba(163, 177, 198, 0.4), -3px -3px 6px rgba(255,255,255, 0.8);
        }
        .ai-switch select {
            border: none; background: transparent; font-weight: bold; color: #333; outline: none;
        }

        .action-group { display: flex; gap: 8px; }
        
        .action-btn {
            border: none; padding: 8px 12px; border-radius: 12px;
            font-weight: bold; font-size: 0.85rem; cursor: pointer;
            box-shadow: 3px 3px 6px rgba(163, 177, 198, 0.4), -3px -3px 6px rgba(255,255,255, 0.8);
            display: flex; align-items: center; gap: 3px;
        }
        .action-btn:active { box-shadow: var(--inner-shadow); transform: scale(0.95); }
        .btn-undo { background: var(--accent-orange); color: #d84315; }
        .btn-reset { background: var(--bg-color); color: #1565c0; }

        /* --- ìƒíƒœ í‘œì‹œì¤„ --- */
        .status-bar {
            display: flex; gap: 15px; align-items: center;
            margin-bottom: 20px; font-weight: bold; font-size: 1.1rem;
            flex-wrap: wrap; justify-content: center;
        }
        
        .omok-rules { display: flex; gap: 10px; font-size: 0.9rem; align-items: center; }
        .checkbox-label {
            display: flex; align-items: center; cursor: pointer;
            background: var(--bg-color); padding: 5px 10px; border-radius: 10px;
            box-shadow: 2px 2px 5px rgba(163, 177, 198, 0.3), -2px -2px 5px rgba(255,255,255,0.8);
        }
        .checkbox-label input { margin-right: 5px; accent-color: var(--accent-brown); }
        .komi-input {
            width: 45px; border: none; background: var(--bg-color);
            box-shadow: var(--inner-shadow); border-radius: 5px;
            padding: 3px; text-align: center; font-weight: bold; color: #555; margin-left: 5px;
        }

        /* --- ë°”ë‘‘íŒ --- */
        .board-container {
            padding: 15px; border-radius: 20px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
        }
        .go-board {
            position: relative; background-color: var(--board-bg);
            padding: calc(var(--grid-size) / 2); border-radius: 4px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
        }
        #grid-layer {
            display: grid;
            grid-template-columns: repeat(18, var(--grid-size));
            grid-template-rows: repeat(18, var(--grid-size));
        }
        .grid-cell {
            width: var(--grid-size); height: var(--grid-size);
            border: 0.5px solid rgba(0,0,0,0.5); box-sizing: border-box;
        }
        .star-point {
            position: absolute; width: 6px; height: 6px; background: #000;
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none;
        }
        #stone-layer {
            position: absolute; top: 0; left: 0;
            display: grid;
            grid-template-columns: repeat(19, var(--grid-size));
            grid-template-rows: repeat(19, var(--grid-size));
        }
        .intersection {
            width: var(--grid-size); height: var(--grid-size);
            display: flex; justify-content: center; align-items: center; z-index: 10;
        }
        .stone {
            width: 90%; height: 90%; border-radius: 50%; position: relative;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        }
        .black { background: radial-gradient(circle at 30% 30%, #555, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }
        .stone.last::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 30%; height: 30%;
            background: rgba(231, 76, 60, 0.9); border-radius: 50%; border: 1px solid white;
        }
        /* AI ìƒê°ì¤‘ ë¡œë”© í‘œì‹œ */
        .thinking { cursor: wait; opacity: 0.7; }

    </style>
</head>
<body>

    <div class="toolbar">
        <div class="mode-switch">
            <button id="btn-omok" class="mode-btn active" onclick="setGameMode('omok')">ì˜¤ëª©</button>
            <button id="btn-go" class="mode-btn" onclick="setGameMode('go')">ë°”ë‘‘</button>
        </div>

        <div class="ai-switch">
            ğŸ¤– <select id="play-mode" onchange="resetGame()">
                <option value="hvh">ì‚¬ëŒ vs ì‚¬ëŒ</option>
                <option value="hva">ì‚¬ëŒ vs AI</option>
            </select>
        </div>
        
        <div class="action-group">
            <button class="action-btn btn-undo" onclick="undoMove()">âª ë¬´ë¥´ê¸°</button>
            <button class="action-btn btn-reset" onclick="resetGame()">ğŸ”„ ë¹„ìš°ê¸°</button>
        </div>
    </div>

    <div class="status-bar">
        <span id="turn-text">í‘ëŒ ì°¨ë¡€</span>
        
        <div id="omok-controls" class="omok-rules">
            <label class="checkbox-label"><input type="checkbox" id="rule33" checked>í‘33ç¦</label>
            <label class="checkbox-label"><input type="checkbox" id="rule44" checked>í‘44ç¦</label>
        </div>
        
        <div id="go-score" class="omok-rules" style="display:none; font-size: 0.9rem; color: #444; align-items: center;">
            <span>í‘ì§‘: <span id="cap-black" style="font-weight:bold">0</span></span>
            <span style="color:#ccc">|</span>
            <span>ë°±ì§‘: <span id="cap-white" style="font-weight:bold">6.5</span></span>
            <span style="font-size:0.8rem; margin-left:5px;">
                (ë¤:<input type="number" id="komi-val" class="komi-input" value="6.5" step="0.5" onchange="updateUI()">)
            </span>
        </div>
    </div>

    <div class="board-container">
        <div class="go-board" id="board-area">
            <div id="grid-layer"></div>
            <div id="stone-layer"></div>
        </div>
    </div>

    <script>
        const size = 19;
        let board = [];
        let currentPlayer = 'black';
        let gameMode = 'omok'; // 'omok' or 'go'
        let playMode = 'hvh'; // 'hvh' or 'hva'
        let historyStack = [];
        let captured = { black: 0, white: 0 };
        let isGameOver = false;
        let koPos = null;
        let isAiThinking = false;

        const gridLayer = document.getElementById('grid-layer');
        const stoneLayer = document.getElementById('stone-layer');
        const turnText = document.getElementById('turn-text');
        const komiInput = document.getElementById('komi-val');
        const playModeSelect = document.getElementById('play-mode');
        const boardArea = document.getElementById('board-area');

        function init() {
            gridLayer.innerHTML = '';
            stoneLayer.innerHTML = '';
            for (let i = 0; i < 18 * 18; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridLayer.appendChild(cell);
            }
            const stars = [3, 9, 15];
            stars.forEach(y => stars.forEach(x => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.top = `calc(${y} * var(--grid-size) + var(--grid-size)/2)`;
                star.style.left = `calc(${x} * var(--grid-size) + var(--grid-size)/2)`;
                gridLayer.appendChild(star);
            }));
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const inter = document.createElement('div');
                    inter.className = 'intersection';
                    inter.id = `cell-${y}-${x}`;
                    inter.onclick = (e) => { e.preventDefault(); handleMove(y, x); };
                    stoneLayer.appendChild(inter);
                }
            }
            resetData();
        }

        function resetData() {
            board = Array.from(Array(size), () => Array(size).fill(null));
            historyStack = [];
            captured = { black: 0, white: 0 };
            currentPlayer = 'black';
            isGameOver = false;
            koPos = null;
            isAiThinking = false;
            boardArea.classList.remove('thinking');
            renderBoard();
            updateUI();
        }

        function setGameMode(mode) {
            if(historyStack.length > 0 && !confirm("ëª¨ë“œ ë³€ê²½ ì‹œ ê²Œì„ì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.")) return;
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            document.getElementById('omok-controls').style.display = (mode === 'omok') ? 'flex' : 'none';
            document.getElementById('go-score').style.display = (mode === 'go') ? 'flex' : 'none';
            resetGame();
        }

        // í†µí•© ì°©ìˆ˜ í•¸ë“¤ëŸ¬
        function handleMove(y, x) {
            if (isGameOver || board[y][x] || isAiThinking) return;

            // ì‚¬ëŒì˜ ì°©ìˆ˜
            if (!executeMove(y, x)) return;

            // AI í„´ ì²˜ë¦¬
            if (!isGameOver && playMode === 'hva' && currentPlayer === 'white') {
                isAiThinking = true;
                boardArea.classList.add('thinking');
                setTimeout(() => {
                    aiMove();
                    isAiThinking = false;
                    boardArea.classList.remove('thinking');
                }, 500); // 0.5ì´ˆ ë”œë ˆì´ë¡œ ìƒê°í•˜ëŠ” ì²™ ì—°ì¶œ
            }
        }

        // ì‹¤ì œ ëŒì„ ë†“ëŠ” ë¡œì§
        function executeMove(y, x) {
            const snapshot = {
                board: JSON.parse(JSON.stringify(board)),
                currentPlayer,
                captured: {...captured},
                koPos
            };

            let success = false;
            if (gameMode === 'omok') success = processOmok(y, x);
            else success = processGo(y, x);

            if (success) {
                historyStack.push({ ...snapshot, move: {y, x} });
                playSound();
                renderBoard(y, x);
                
                if (gameMode === 'omok' && checkOmokWin(y, x)) {
                    setTimeout(() => alert(`${currentPlayer==='black'?'í‘':'ë°±'} ìŠ¹ë¦¬!`), 20);
                    isGameOver = true;
                    return true;
                }
                
                currentPlayer = (currentPlayer === 'black') ? 'white' : 'black';
                updateUI();
                return true;
            }
            return false;
        }

        // --- AI Logic (Heuristic) ---
        function aiMove() {
            if (isGameOver) return;
            
            let bestMove = null;
            
            // ë°”ë‘‘ AI (ë‹¨ìˆœ ëœë¤/í™œë¡œ ê¸°ë°˜ - ë§¤ìš° ì•½í•¨)
            if (gameMode === 'go') {
                bestMove = getBasicGoMove();
            } 
            // ì˜¤ëª© AI (íŒ¨í„´ ë§¤ì¹­ - ê½¤ ì“¸ë§Œí•¨)
            else {
                bestMove = getOmokBestMove();
            }

            if (bestMove) {
                executeMove(bestMove.y, bestMove.x);
            } else {
                alert("AIê°€ ë‘˜ ê³³ì´ ì—†ìŠµë‹ˆë‹¤. ë¬´ìŠ¹ë¶€?");
            }
        }

        function getOmokBestMove() {
            let maxScore = -Infinity;
            let moves = [];
            const center = Math.floor(size / 2);

            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(!board[y][x]) {
                        // AIëŠ” ë°±ëŒ(white), í”Œë ˆì´ì–´ëŠ” í‘ëŒ(black)
                        // ê³µê²© ì ìˆ˜ (ë‚´ ëŒ ì—°ê²°)
                        const attackScore = evaluatePos(y, x, 'white');
                        // ë°©ì–´ ì ìˆ˜ (ìƒëŒ€ ëŒ ë§‰ê¸° - ê°€ì¤‘ì¹˜ ë†’ìŒ)
                        const defenseScore = evaluatePos(y, x, 'black');
                        
                        // ì¤‘ì•™ ê°€ì¤‘ì¹˜ (ì´ˆë°˜ì— ì¤‘ì•™ ì„ í˜¸)
                        const dist = Math.abs(y - center) + Math.abs(x - center);
                        const centerBonus = (size - dist); 

                        // ì´ì  = ê³µê²© + ë°©ì–´ + ìœ„ì¹˜ì ìˆ˜
                        // ë°©ì–´ê°€ ì¤‘ìš”í•˜ë¯€ë¡œ defenseScoreì— ì•½ê°„ ê°€ì¤‘ì¹˜
                        let totalScore = attackScore + (defenseScore * 1.1) + centerBonus;

                        if (totalScore > maxScore) {
                            maxScore = totalScore;
                            moves = [{y, x}];
                        } else if (totalScore === maxScore) {
                            moves.push({y, x});
                        }
                    }
                }
            }
            return moves.length > 0 ? moves[Math.floor(Math.random() * moves.length)] : null;
        }

        function evaluatePos(y, x, color) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            let score = 0;

            dirs.forEach(([dy, dx]) => {
                let count = 1; // í˜„ì¬ ìœ„ì¹˜ í¬í•¨
                let blocked = 0;
                
                // ì •ë°©í–¥ íƒìƒ‰
                let i=1; 
                while(board[y+dy*i]?.[x+dx*i] === color) { count++; i++; }
                if(board[y+dy*i]?.[x+dx*i] !== null) blocked++; // ë²½ì´ë‚˜ ìƒëŒ€ëŒ

                // ì—­ë°©í–¥ íƒìƒ‰
                let j=1; 
                while(board[y-dy*j]?.[x-dx*j] === color) { count++; j++; }
                if(board[y-dy*j]?.[x-dx*j] !== null) blocked++;

                // ì ìˆ˜ ë¶€ì—¬ ê·œì¹™
                if (count >= 5) score += 100000; // 5ëª© (ìŠ¹ë¦¬)
                else if (count === 4) {
                    if (blocked === 0) score += 10000; // ì—´ë¦° 4 (ë‹¤ìŒ í„´ ìŠ¹ë¦¬)
                    else if (blocked === 1) score += 1000; // ë‹«íŒ 4
                }
                else if (count === 3) {
                    if (blocked === 0) score += 500; // ì—´ë¦° 3
                    else if (blocked === 1) score += 50;
                }
                else if (count === 2) {
                    if (blocked === 0) score += 10;
                }
            });
            return score;
        }

        function getBasicGoMove() {
            // ë°”ë‘‘ AIëŠ” ë„ˆë¬´ ë³µì¡í•˜ë¯€ë¡œ ëœë¤ìœ¼ë¡œ ë‘ë˜, ìì‚´ìˆ˜ëŠ” í”¼í•¨
            let validMoves = [];
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(!board[y][x]) {
                        // ê°€ìƒìœ¼ë¡œ ë‘¬ë³´ê³  ìì‚´ìˆ˜ ì²´í¬ (ì•½ì‹)
                        board[y][x] = 'white';
                        let myGroup = getGroup(y, x, 'white');
                        let liberties = getLiberties(myGroup);
                        board[y][x] = null; // ë³µêµ¬
                        
                        // ì ì–´ë„ í™œë¡œê°€ ìˆëŠ” ê³³ì— ë‘ 
                        if(liberties > 0) validMoves.push({y, x});
                    }
                }
            }
            if(validMoves.length > 0) {
                // ì¤‘ì•™ ê·¼ì²˜ë¥¼ ì„ í˜¸í•˜ë„ë¡ ì •ë ¬
                const center = Math.floor(size/2);
                validMoves.sort((a,b) => {
                    let d1 = Math.abs(a.y-center)+Math.abs(a.x-center);
                    let d2 = Math.abs(b.y-center)+Math.abs(b.x-center);
                    return d1 - d2 + (Math.random()*4 - 2); // ì•½ê°„ì˜ ëœë¤ì„±
                });
                return validMoves[0]; 
            }
            return null;
        }


        // --- ê¸°ì¡´ ì˜¤ëª©/ë°”ë‘‘ ê·œì¹™ ë¡œì§ ---
        function processOmok(y, x) {
            if (currentPlayer === 'black') {
                const r33 = document.getElementById('rule33').checked;
                const r44 = document.getElementById('rule44').checked;
                if (r33 && checkForbidden(y, x, 3)) { alert("3-3 ê¸ˆìˆ˜!"); return false; }
                if (r44 && checkForbidden(y, x, 4)) { alert("4-4 ê¸ˆìˆ˜!"); return false; }
            }
            board[y][x] = currentPlayer;
            return true;
        }

        function checkForbidden(y, x, k) {
            board[y][x] = 'black';
            let cnt = 0;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let c = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === 'black') { c++; i++; }
                let j=1; while(board[y-dy*j]?.[x-dx*j] === 'black') { c++; j++; }
                if(c === k) cnt++;
            }
            board[y][x] = null;
            return cnt >= 2;
        }

        function checkOmokWin(y, x) {
            const c = board[y][x];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let count = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === c) { count++; i++; }
                i=1; while(board[y-dy*i]?.[x-dx*i] === c) { count++; i++; }
                if(count >= 5) return true;
            }
            return false;
        }

        function processGo(y, x) {
            if (koPos && koPos.y === y && koPos.x === x) {
                if(playMode === 'hvh') alert("íŒ¨(Ko)ì…ë‹ˆë‹¤.");
                return false;
            }
            const opponent = (currentPlayer === 'black') ? 'white' : 'black';
            board[y][x] = currentPlayer;
            let capturedStones = [];
            const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];
            neighbors.forEach(([dy, dx]) => {
                const ny=y+dy, nx=x+dx;
                if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===opponent) {
                    const group = getGroup(ny, nx, opponent);
                    if(getLiberties(group) === 0) capturedStones.push(...group);
                }
            });
            const myGroup = getGroup(y, x, currentPlayer);
            if(capturedStones.length === 0 && getLiberties(myGroup) === 0) {
                board[y][x] = null;
                if(playMode === 'hvh') alert("ì°©ìˆ˜ ê¸ˆì§€(ìì‚´ìˆ˜)");
                return false;
            }
            capturedStones.forEach(p => board[p.y][p.x] = null);
            captured[currentPlayer] += capturedStones.length;
            if (capturedStones.length === 1 && myGroup.length === 1 && getLiberties(myGroup) === 1) {
                koPos = capturedStones[0];
            } else {
                koPos = null;
            }
            return true;
        }

        function getGroup(y, x, color) {
            let g = [], visited = new Set(), stack = [{y, x}];
            visited.add(`${y},${x}`);
            while(stack.length) {
                let cur = stack.pop(); g.push(cur);
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=cur.y+dy, nx=cur.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===color && !visited.has(`${ny},${nx}`)) {
                        visited.add(`${ny},${nx}`); stack.push({y:ny, x:nx});
                    }
                });
            }
            return g;
        }

        function getLiberties(group) {
            let lib = new Set();
            group.forEach(p => {
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=p.y+dy, nx=p.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===null) lib.add(`${ny},${nx}`);
                });
            });
            return lib.size;
        }

        function undoMove() {
            if(historyStack.length === 0) return;
            // AI ëª¨ë“œì¼ ê²½ìš° ë‘ ë²ˆ ë¬´ë¥´ê¸° (ë‚´ ê²ƒ + AI ê²ƒ)
            let steps = (playMode === 'hva' && historyStack.length >= 2) ? 2 : 1;
            
            for(let i=0; i<steps; i++) {
                const prev = historyStack.pop();
                board = prev.board;
                currentPlayer = prev.currentPlayer;
                captured = prev.captured;
                koPos = prev.koPos;
            }
            isGameOver = false;
            let lastMove = historyStack.length > 0 ? historyStack[historyStack.length-1].move : {y:-1, x:-1};
            renderBoard(lastMove.y, lastMove.x);
            updateUI();
        }

        function renderBoard(lastY = -1, lastX = -1) {
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    const cell = document.getElementById(`cell-${y}-${x}`);
                    cell.innerHTML = '';
                    if(board[y][x]) {
                        const s = document.createElement('div');
                        s.className = `stone ${board[y][x]}`;
                        if(y===lastY && x===lastX) s.classList.add('last');
                        cell.appendChild(s);
                    }
                }
            }
        }

        function updateUI() {
            playModeSelect.value = playMode;
            playMode = playModeSelect.value; // Sync var
            turnText.innerText = `${currentPlayer === 'black' ? 'í‘ëŒ' : 'ë°±ëŒ'} ì°¨ë¡€`;
            document.getElementById('cap-black').innerText = captured.white;
            const komi = parseFloat(komiInput.value) || 0;
            document.getElementById('cap-white').innerText = captured.black + komi;
        }

        function resetGame() { 
            playMode = playModeSelect.value;
            resetData(); 
        }

        function playSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            } catch(e) {}
        }

        window.onload = init;
    </script>
</body>
</html>
