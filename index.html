<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clean Omok & Baduk (+Komi)</title>
    <style>
        :root {
            --bg-color: #e0e5ec;
            --text-color: #4a4a4a;
            --board-bg: #e3a05b;
            --accent-brown: #5d4037;
            --accent-orange: #ffcc80;
            --accent-blue: #e3f2fd;
            
            /* Neumorphism Shadows */
            --shadow-light: -9px -9px 16px rgba(255, 255, 255, 0.8);
            --shadow-dark: 9px 9px 16px rgba(163, 177, 198, 0.6);
            --inner-shadow: inset 6px 6px 10px 0 rgba(163, 177, 198, 0.7), 
                            inset -6px -6px 10px 0 rgba(255, 255, 255, 0.8);
            
            --grid-size: 5.2vw;
        }
        @media (min-width: 600px) { :root { --grid-size: 32px; } }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 20px 0;
            display: flex; flex-direction: column; align-items: center;
            background-color: var(--bg-color);
            font-family: 'Pretendard', -apple-system, sans-serif;
            color: var(--text-color);
            touch-action: manipulation;
        }

        /* --- 1. ÏÉÅÎã® Ìà¥Î∞î --- */
        .toolbar {
            width: 92%; max-width: 450px;
            padding: 10px 15px;
            border-radius: 50px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px;
        }

        .mode-switch {
            background: var(--bg-color);
            box-shadow: var(--inner-shadow);
            border-radius: 30px;
            padding: 4px;
            display: flex;
        }
        
        .mode-btn {
            border: none; background: transparent;
            padding: 8px 20px; border-radius: 25px;
            font-weight: bold; color: #888; cursor: pointer;
            transition: 0.3s;
        }
        .mode-btn.active {
            background: var(--accent-brown); color: white;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        .action-group { display: flex; gap: 10px; }
        
        .action-btn {
            border: none; padding: 8px 18px; border-radius: 12px;
            font-weight: bold; font-size: 0.9rem; cursor: pointer;
            box-shadow: 3px 3px 6px rgba(163, 177, 198, 0.4), -3px -3px 6px rgba(255,255,255, 0.8);
            transition: 0.2s; display: flex; align-items: center; gap: 5px;
        }
        .action-btn:active { box-shadow: var(--inner-shadow); transform: scale(0.95); }
        
        .btn-undo { background: var(--accent-orange); color: #d84315; }
        .btn-reset { background: var(--bg-color); color: #1565c0; }

        /* --- 2. ÏÉÅÌÉú ÌëúÏãúÏ§Ñ --- */
        .status-bar {
            display: flex; gap: 15px; align-items: center;
            margin-bottom: 20px; font-weight: bold; font-size: 1.1rem;
            flex-wrap: wrap; justify-content: center;
        }
        
        .omok-rules { display: flex; gap: 10px; font-size: 0.9rem; align-items: center; }
        .checkbox-label {
            display: flex; align-items: center; cursor: pointer;
            background: var(--bg-color); padding: 5px 10px; border-radius: 10px;
            box-shadow: 2px 2px 5px rgba(163, 177, 198, 0.3), -2px -2px 5px rgba(255,255,255,0.8);
        }
        .checkbox-label input { margin-right: 5px; accent-color: var(--accent-brown); }

        /* Îç§ ÏûÖÎ†• ÌïÑÎìú Ïä§ÌÉÄÏùº Ï∂îÍ∞Ä */
        .komi-input {
            width: 50px;
            border: none;
            background: var(--bg-color);
            box-shadow: var(--inner-shadow);
            border-radius: 5px;
            padding: 3px;
            text-align: center;
            font-weight: bold;
            color: #555;
            margin-left: 5px;
        }

        /* --- 3. Î∞îÎëëÌåê --- */
        .board-container {
            padding: 15px;
            border-radius: 20px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
        }

        .go-board {
            position: relative;
            background-color: var(--board-bg);
            padding: calc(var(--grid-size) / 2);
            border-radius: 4px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
        }

        #grid-layer {
            display: grid;
            grid-template-columns: repeat(18, var(--grid-size));
            grid-template-rows: repeat(18, var(--grid-size));
        }
        
        .grid-cell {
            width: var(--grid-size); height: var(--grid-size);
            border: 0.5px solid rgba(0,0,0,0.5); box-sizing: border-box;
        }

        .star-point {
            position: absolute; width: 6px; height: 6px; background: #000;
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none;
        }

        #stone-layer {
            position: absolute; top: 0; left: 0;
            display: grid;
            grid-template-columns: repeat(19, var(--grid-size));
            grid-template-rows: repeat(19, var(--grid-size));
        }
        
        .intersection {
            width: var(--grid-size); height: var(--grid-size);
            display: flex; justify-content: center; align-items: center; z-index: 10;
        }

        .stone {
            width: 90%; height: 90%; border-radius: 50%; position: relative;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        }
        .black { background: radial-gradient(circle at 30% 30%, #555, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }

        .stone.last::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 30%; height: 30%;
            background: rgba(231, 76, 60, 0.9); border-radius: 50%;
            border: 1px solid white;
        }

    </style>
</head>
<body>

    <div class="toolbar">
        <div class="mode-switch">
            <button id="btn-omok" class="mode-btn active" onclick="setMode('omok')">Ïò§Î™©</button>
            <button id="btn-go" class="mode-btn" onclick="setMode('go')">Î∞îÎëë</button>
        </div>
        
        <div class="action-group">
            <button class="action-btn btn-undo" onclick="undoMove()">‚è™ Î¨¥Î•¥Í∏∞</button>
            <button class="action-btn btn-reset" onclick="resetGame()">üîÑ Îã§ÏãúÎëêÍ∏∞</button>
        </div>
    </div>

    <div class="status-bar">
        <span id="turn-text">ÌùëÎèå Ï∞®Î°Ä</span>
        
        <div id="omok-controls" class="omok-rules">
            <label class="checkbox-label"><input type="checkbox" id="rule33" checked>Ìùë3-3Í∏àÏßÄ</label>
            <label class="checkbox-label"><input type="checkbox" id="rule44" checked>Ìùë4-4Í∏àÏßÄ</label>
        </div>
        
        <div id="go-score" class="omok-rules" style="display:none; font-size: 0.9rem; color: #444; align-items: center;">
            <span>ÌùëÏßë: <span id="cap-black" style="font-weight:bold">0</span></span>
            <span style="color:#ccc">|</span>
            <span>Î∞±Ïßë: <span id="cap-white" style="font-weight:bold">6.5</span></span>
            <span style="font-size:0.8rem; margin-left:5px;">
                (Îç§: <input type="number" id="komi-val" class="komi-input" value="6.5" step="0.5" onchange="updateUI()">)
            </span>
        </div>
    </div>

    <div class="board-container">
        <div class="go-board">
            <div id="grid-layer"></div>
            <div id="stone-layer"></div>
        </div>
    </div>

    <script>
        const size = 19;
        let board = [];
        let currentPlayer = 'black';
        let gameMode = 'omok';
        let historyStack = [];
        let captured = { black: 0, white: 0 }; // [ÎÇ¥ ÏÉâÍπî]Ïù¥ Îî∞ÎÇ∏ Îèå Ïàò
        let isGameOver = false;
        let koPos = null;

        const gridLayer = document.getElementById('grid-layer');
        const stoneLayer = document.getElementById('stone-layer');
        const turnText = document.getElementById('turn-text');
        const komiInput = document.getElementById('komi-val'); // Îç§ ÏûÖÎ†• ÏöîÏÜå

        function init() {
            gridLayer.innerHTML = '';
            stoneLayer.innerHTML = '';

            for (let i = 0; i < 18 * 18; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridLayer.appendChild(cell);
            }
            const stars = [3, 9, 15];
            stars.forEach(y => stars.forEach(x => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.top = `calc(${y} * var(--grid-size) + var(--grid-size)/2)`;
                star.style.left = `calc(${x} * var(--grid-size) + var(--grid-size)/2)`;
                gridLayer.appendChild(star);
            }));

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const inter = document.createElement('div');
                    inter.className = 'intersection';
                    inter.id = `cell-${y}-${x}`;
                    inter.onclick = (e) => { e.preventDefault(); handleMove(y, x); };
                    stoneLayer.appendChild(inter);
                }
            }
            resetData();
        }

        function resetData() {
            board = Array.from(Array(size), () => Array(size).fill(null));
            historyStack = [];
            captured = { black: 0, white: 0 };
            currentPlayer = 'black';
            isGameOver = false;
            koPos = null;
            renderBoard();
            updateUI();
        }

        function setMode(mode) {
            if(historyStack.length > 0 && !confirm("Î™®Îìú Î≥ÄÍ≤Ω Ïãú Í≤åÏûÑÏù¥ Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§. ÏßÑÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) return;
            gameMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            
            document.getElementById('omok-controls').style.display = (mode === 'omok') ? 'flex' : 'none';
            document.getElementById('go-score').style.display = (mode === 'go') ? 'flex' : 'none';
            
            resetGame();
        }

        function handleMove(y, x) {
            if (isGameOver || board[y][x]) return;

            const snapshot = {
                board: JSON.parse(JSON.stringify(board)),
                currentPlayer,
                captured: {...captured},
                koPos
            };

            let success = false;
            if (gameMode === 'omok') success = processOmok(y, x);
            else success = processGo(y, x);

            if (success) {
                historyStack.push({ ...snapshot, move: {y, x} });
                playSound();
                renderBoard(y, x);
                
                if (gameMode === 'omok' && checkOmokWin(y, x)) {
                    setTimeout(() => alert(`${currentPlayer==='black'?'Ìùë':'Î∞±'} ÏäπÎ¶¨!`), 20);
                    isGameOver = true;
                    return;
                }
                
                currentPlayer = (currentPlayer === 'black') ? 'white' : 'black';
                updateUI();
            }
        }

        function processOmok(y, x) {
            if (currentPlayer === 'black') {
                const r33 = document.getElementById('rule33').checked;
                const r44 = document.getElementById('rule44').checked;
                if (r33 && checkForbidden(y, x, 3)) { alert("3-3 Í∏àÏàòÏûÖÎãàÎã§."); return false; }
                if (r44 && checkForbidden(y, x, 4)) { alert("4-4 Í∏àÏàòÏûÖÎãàÎã§."); return false; }
            }
            board[y][x] = currentPlayer;
            return true;
        }

        function checkForbidden(y, x, k) {
            board[y][x] = 'black';
            let cnt = 0;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let c = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === 'black') { c++; i++; }
                let j=1; while(board[y-dy*j]?.[x-dx*j] === 'black') { c++; j++; }
                if(c === k) cnt++;
            }
            board[y][x] = null;
            return cnt >= 2;
        }

        function checkOmokWin(y, x) {
            const c = board[y][x];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let count = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === c) { count++; i++; }
                i=1; while(board[y-dy*i]?.[x-dx*i] === c) { count++; i++; }
                if(count >= 5) return true;
            }
            return false;
        }

        function processGo(y, x) {
            if (koPos && koPos.y === y && koPos.x === x) {
                alert("Ìå®(Ko)ÏûÖÎãàÎã§. Îã§Î•∏ Í≥≥Ïóê ÎëêÏÑ∏Ïöî."); return false;
            }
            
            const opponent = (currentPlayer === 'black') ? 'white' : 'black';
            board[y][x] = currentPlayer;
            let capturedStones = [];
            const neighbors = [[0,1],[0,-1],[1,0],[-1,0]];

            neighbors.forEach(([dy, dx]) => {
                const ny=y+dy, nx=x+dx;
                if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===opponent) {
                    const group = getGroup(ny, nx, opponent);
                    if(getLiberties(group) === 0) capturedStones.push(...group);
                }
            });

            const myGroup = getGroup(y, x, currentPlayer);
            if(capturedStones.length === 0 && getLiberties(myGroup) === 0) {
                board[y][x] = null;
                alert("Ï∞©Ïàò Í∏àÏßÄ(ÏûêÏÇ¥Ïàò)ÏûÖÎãàÎã§.");
                return false;
            }

            capturedStones.forEach(p => board[p.y][p.x] = null);
            captured[currentPlayer] += capturedStones.length;

            if (capturedStones.length === 1 && myGroup.length === 1 && getLiberties(myGroup) === 1) {
                koPos = capturedStones[0];
            } else {
                koPos = null;
            }
            return true;
        }

        function getGroup(y, x, color) {
            let g = [], visited = new Set(), stack = [{y, x}];
            visited.add(`${y},${x}`);
            while(stack.length) {
                let cur = stack.pop(); g.push(cur);
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=cur.y+dy, nx=cur.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===color && !visited.has(`${ny},${nx}`)) {
                        visited.add(`${ny},${nx}`); stack.push({y:ny, x:nx});
                    }
                });
            }
            return g;
        }

        function getLiberties(group) {
            let lib = new Set();
            group.forEach(p => {
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=p.y+dy, nx=p.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===null) lib.add(`${ny},${nx}`);
                });
            });
            return lib.size;
        }

        function undoMove() {
            if(historyStack.length === 0) return;
            const prev = historyStack.pop();
            board = prev.board;
            currentPlayer = prev.currentPlayer;
            captured = prev.captured;
            koPos = prev.koPos;
            isGameOver = false;
            
            let lastMove = historyStack.length > 0 ? historyStack[historyStack.length-1].move : {y:-1, x:-1};
            renderBoard(lastMove.y, lastMove.x);
            updateUI();
        }

        function renderBoard(lastY = -1, lastX = -1) {
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    const cell = document.getElementById(`cell-${y}-${x}`);
                    cell.innerHTML = '';
                    if(board[y][x]) {
                        const s = document.createElement('div');
                        s.className = `stone ${board[y][x]}`;
                        if(y===lastY && x===lastX) s.classList.add('last');
                        cell.appendChild(s);
                    }
                }
            }
        }

        // UI ÏóÖÎç∞Ïù¥Ìä∏: Îç§ Í∏∞Îä• Î°úÏßÅ Ï∂îÍ∞Ä
        function updateUI() {
            turnText.innerText = `${currentPlayer === 'black' ? 'ÌùëÎèå' : 'Î∞±Îèå'} Ï∞®Î°Ä`;
            
            // ÌùëÏßë = Î∞±ÎèåÏùÑ Îî∞ÎÇ∏ Ïàò
            document.getElementById('cap-black').innerText = captured.white;
            
            // Î∞±Ïßë = ÌùëÎèåÏùÑ Îî∞ÎÇ∏ Ïàò + Îç§(Komi)
            const komi = parseFloat(komiInput.value) || 0;
            const whiteScore = captured.black + komi;
            
            document.getElementById('cap-white').innerText = whiteScore;
        }

        function resetGame() { resetData(); }

        function playSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            } catch(e) {}
        }

        window.onload = init;
    </script>
</body>
</html>

