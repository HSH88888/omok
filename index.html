<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smooth AI Omok & Baduk</title>
    <style>
        :root {
            --bg-color: #e0e5ec;
            --text-color: #4a4a4a;
            --board-bg: #e3a05b;
            --accent-brown: #5d4037;
            --accent-orange: #ffcc80;
            
            /* Neumorphism Shadows */
            --shadow-light: -9px -9px 16px rgba(255, 255, 255, 0.8);
            --shadow-dark: 9px 9px 16px rgba(163, 177, 198, 0.6);
            --inner-shadow: inset 6px 6px 10px 0 rgba(163, 177, 198, 0.7), 
                            inset -6px -6px 10px 0 rgba(255, 255, 255, 0.8);
            
            --grid-size: 5.2vw;
        }
        @media (min-width: 600px) { :root { --grid-size: 32px; } }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 20px 0;
            display: flex; flex-direction: column; align-items: center;
            background-color: var(--bg-color);
            font-family: 'Pretendard', -apple-system, sans-serif;
            color: var(--text-color);
            touch-action: manipulation;
        }

        /* Ìà¥Î∞î Ïä§ÌÉÄÏùº */
        .toolbar {
            width: 95%; max-width: 500px;
            padding: 10px 15px;
            border-radius: 50px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
            gap: 10px; margin-bottom: 20px;
        }

        .mode-switch {
            background: var(--bg-color);
            box-shadow: var(--inner-shadow);
            border-radius: 30px; padding: 4px; display: flex;
        }
        
        .mode-btn {
            border: none; background: transparent;
            padding: 8px 15px; border-radius: 25px;
            font-weight: bold; color: #888; cursor: pointer; transition: 0.3s;
            font-size: 0.85rem;
        }
        .mode-btn.active {
            background: var(--accent-brown); color: white;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        .ai-switch {
            display: flex; align-items: center; gap: 5px;
            font-size: 0.85rem; font-weight: bold;
            background: var(--bg-color); padding: 5px 10px; border-radius: 20px;
            box-shadow: 3px 3px 6px rgba(163, 177, 198, 0.4), -3px -3px 6px rgba(255,255,255, 0.8);
        }
        .ai-switch select {
            border: none; background: transparent; font-weight: bold; color: #333; outline: none;
        }

        .action-group { display: flex; gap: 8px; }
        .action-btn {
            border: none; padding: 8px 12px; border-radius: 12px;
            font-weight: bold; font-size: 0.85rem; cursor: pointer;
            box-shadow: 3px 3px 6px rgba(163, 177, 198, 0.4), -3px -3px 6px rgba(255,255,255, 0.8);
            display: flex; align-items: center; gap: 3px;
        }
        .action-btn:active { box-shadow: var(--inner-shadow); transform: scale(0.95); }
        .btn-undo { background: var(--accent-orange); color: #d84315; }
        .btn-reset { background: var(--bg-color); color: #1565c0; }

        /* ÏÉÅÌÉú ÌëúÏãúÏ§Ñ */
        .status-bar {
            display: flex; gap: 15px; align-items: center;
            margin-bottom: 20px; font-weight: bold; font-size: 1.1rem;
            flex-wrap: wrap; justify-content: center;
        }
        .omok-rules { display: flex; gap: 10px; font-size: 0.9rem; align-items: center; }
        .checkbox-label {
            display: flex; align-items: center; cursor: pointer;
            background: var(--bg-color); padding: 5px 10px; border-radius: 10px;
            box-shadow: 2px 2px 5px rgba(163, 177, 198, 0.3), -2px -2px 5px rgba(255,255,255,0.8);
        }
        .komi-input {
            width: 45px; border: none; background: var(--bg-color);
            box-shadow: var(--inner-shadow); border-radius: 5px;
            padding: 3px; text-align: center; font-weight: bold; color: #555; margin-left: 5px;
        }

        /* Î∞îÎëëÌåê */
        .board-container {
            padding: 15px; border-radius: 20px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
        }
        .go-board {
            position: relative; background-color: var(--board-bg);
            padding: calc(var(--grid-size) / 2); border-radius: 4px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
        }
        #grid-layer {
            display: grid;
            grid-template-columns: repeat(18, var(--grid-size));
            grid-template-rows: repeat(18, var(--grid-size));
        }
        .grid-cell {
            width: var(--grid-size); height: var(--grid-size);
            border: 0.5px solid rgba(0,0,0,0.5); box-sizing: border-box;
        }
        .star-point {
            position: absolute; width: 6px; height: 6px; background: #000;
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none;
        }
        #stone-layer {
            position: absolute; top: 0; left: 0;
            display: grid;
            grid-template-columns: repeat(19, var(--grid-size));
            grid-template-rows: repeat(19, var(--grid-size));
        }
        .intersection {
            width: var(--grid-size); height: var(--grid-size);
            display: flex; justify-content: center; align-items: center; z-index: 10;
        }
        
        .stone {
            width: 90%; height: 90%; border-radius: 50%; position: relative;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            transition: transform 0.1s; /* Î∂ÄÎìúÎü¨Ïö¥ Îì±Ïû• */
        }
        .black { background: radial-gradient(circle at 30% 30%, #555, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }
        
        .stone.last::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 30%; height: 30%;
            background: rgba(231, 76, 60, 0.9); border-radius: 50%; border: 1px solid white;
        }

        /* ÏàòÏ†ïÎêú ÏÉùÍ∞ÅÏ§ë Ïä§ÌÉÄÏùº: Ìà¨Î™ÖÎèÑ Î≥ÄÌôî Ï†úÍ±∞ -> ÍπúÎπ°ÏûÑ Ìï¥Í≤∞ */
        .thinking { 
            cursor: wait; 
            pointer-events: none; /* ÌÅ¥Î¶≠Îßå Î∞©ÏßÄ */
        }

    </style>
</head>
<body>

    <div class="toolbar">
        <div class="mode-switch">
            <button id="btn-omok" class="mode-btn active" onclick="setGameMode('omok')">Ïò§Î™©</button>
            <button id="btn-go" class="mode-btn" onclick="setGameMode('go')">Î∞îÎëë</button>
        </div>

        <div class="ai-switch">
            ü§ñ <select id="play-mode" onchange="resetGame()">
                <option value="hvh">ÏÇ¨Îûå vs ÏÇ¨Îûå</option>
                <option value="hva">ÏÇ¨Îûå vs AI</option>
            </select>
        </div>
        
        <div class="action-group">
            <button class="action-btn btn-undo" onclick="undoMove()">‚è™ Î¨¥Î•¥Í∏∞</button>
            <button class="action-btn btn-reset" onclick="resetGame()">üîÑ ÎπÑÏö∞Í∏∞</button>
        </div>
    </div>

    <div class="status-bar">
        <span id="turn-text">ÌùëÎèå Ï∞®Î°Ä</span>
        
        <div id="omok-controls" class="omok-rules">
            <label class="checkbox-label"><input type="checkbox" id="rule33" checked>Ìùë33Á¶Å</label>
            <label class="checkbox-label"><input type="checkbox" id="rule44" checked>Ìùë44Á¶Å</label>
        </div>
        
        <div id="go-score" class="omok-rules" style="display:none; font-size: 0.9rem; color: #444; align-items: center;">
            <span>ÌùëÏßë: <span id="cap-black" style="font-weight:bold">0</span></span>
            <span style="color:#ccc">|</span>
            <span>Î∞±Ïßë: <span id="cap-white" style="font-weight:bold">6.5</span></span>
            <span style="font-size:0.8rem; margin-left:5px;">
                (Îç§:<input type="number" id="komi-val" class="komi-input" value="6.5" step="0.5" onchange="updateUI()">)
            </span>
        </div>
    </div>

    <div class="board-container">
        <div class="go-board" id="board-area">
            <div id="grid-layer"></div>
            <div id="stone-layer"></div>
        </div>
    </div>

    <script>
        const size = 19;
        let board = [];
        let currentPlayer = 'black';
        let gameMode = 'omok'; 
        let playMode = 'hvh'; 
        let historyStack = [];
        let captured = { black: 0, white: 0 };
        let isGameOver = false;
        let koPos = null;
        let isAiThinking = false;

        const gridLayer = document.getElementById('grid-layer');
        const stoneLayer = document.getElementById('stone-layer');
        const turnText = document.getElementById('turn-text');
        const komiInput = document.getElementById('komi-val');
        const playModeSelect = document.getElementById('play-mode');
        const boardArea = document.getElementById('board-area');

        function init() {
            gridLayer.innerHTML = '';
            stoneLayer.innerHTML = '';
            for (let i = 0; i < 18 * 18; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridLayer.appendChild(cell);
            }
            const stars = [3, 9, 15];
            stars.forEach(y => stars.forEach(x => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.top = `calc(${y} * var(--grid-size) + var(--grid-size)/2)`;
                star.style.left = `calc(${x} * var(--grid-size) + var(--grid-size)/2)`;
                gridLayer.appendChild(star);
            }));
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const inter = document.createElement('div');
                    inter.className = 'intersection';
                    inter.id = `cell-${y}-${x}`;
                    inter.onclick = (e) => { e.preventDefault(); handleMove(y, x); };
                    stoneLayer.appendChild(inter);
                }
            }
            resetData();
        }

        function resetData() {
            board = Array.from(Array(size), () => Array(size).fill(null));
            historyStack = [];
            captured = { black: 0, white: 0 };
            currentPlayer = 'black';
            isGameOver = false;
            koPos = null;
            isAiThinking = false;
            boardArea.classList.remove('thinking');
            renderBoard(); // Force full render
            updateUI();
        }

        function setGameMode(mode) {
            if(historyStack.length > 0 && !confirm("Î™®Îìú Î≥ÄÍ≤Ω Ïãú Í≤åÏûÑÏù¥ Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§.")) return;
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            document.getElementById('omok-controls').style.display = (mode === 'omok') ? 'flex' : 'none';
            document.getElementById('go-score').style.display = (mode === 'go') ? 'flex' : 'none';
            resetGame();
        }

        function handleMove(y, x) {
            if (isGameOver || board[y][x] || isAiThinking) return;

            if (!executeMove(y, x)) return;

            // AI ÌÑ¥
            if (!isGameOver && playMode === 'hva' && currentPlayer === 'white') {
                isAiThinking = true;
                boardArea.classList.add('thinking'); // ÌÅ¥Î¶≠ Î∞©ÏßÄ, ÍπúÎπ°ÏûÑ ÏóÜÏùå
                
                // setTimeoutÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Î∏åÎùºÏö∞Ï†ÄÍ∞Ä UIÎ•º Í∑∏Î¶¥ ÏãúÍ∞ÑÏùÑ Ï§å
                setTimeout(() => {
                    aiMove();
                    isAiThinking = false;
                    boardArea.classList.remove('thinking');
                }, 300); 
            }
        }

        function executeMove(y, x) {
            const snapshot = {
                board: JSON.parse(JSON.stringify(board)),
                currentPlayer,
                captured: {...captured},
                koPos
            };

            let success = false;
            if (gameMode === 'omok') success = processOmok(y, x);
            else success = processGo(y, x);

            if (success) {
                historyStack.push({ ...snapshot, move: {y, x} });
                playSound();
                renderBoard(y, x); // ÏµúÏ†ÅÌôîÎêú Î†åÎçîÎßÅ Ìò∏Ï∂ú
                
                if (gameMode === 'omok' && checkOmokWin(y, x)) {
                    setTimeout(() => alert(`${currentPlayer==='black'?'Ìùë':'Î∞±'} ÏäπÎ¶¨!`), 20);
                    isGameOver = true;
                    return true;
                }
                
                currentPlayer = (currentPlayer === 'black') ? 'white' : 'black';
                updateUI();
                return true;
            }
            return false;
        }

        // --- AI Logic ---
        function aiMove() {
            if (isGameOver) return;
            let bestMove = (gameMode === 'go') ? getBasicGoMove() : getOmokBestMove();
            if (bestMove) executeMove(bestMove.y, bestMove.x);
        }

        function getOmokBestMove() {
            let maxScore = -Infinity;
            let moves = [];
            const center = Math.floor(size / 2);
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(!board[y][x]) {
                        const attackScore = evaluatePos(y, x, 'white');
                        const defenseScore = evaluatePos(y, x, 'black');
                        const dist = Math.abs(y - center) + Math.abs(x - center);
                        const centerBonus = (size - dist); 
                        let totalScore = attackScore + (defenseScore * 1.15) + centerBonus; 
                        if (totalScore > maxScore) {
                            maxScore = totalScore;
                            moves = [{y, x}];
                        } else if (totalScore === maxScore) {
                            moves.push({y, x});
                        }
                    }
                }
            }
            return moves.length > 0 ? moves[Math.floor(Math.random() * moves.length)] : null;
        }

        function evaluatePos(y, x, color) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            let score = 0;
            dirs.forEach(([dy, dx]) => {
                let count = 1; let blocked = 0;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === color) { count++; i++; }
                if(board[y+dy*i]?.[x+dx*i] !== null) blocked++;
                let j=1; while(board[y-dy*j]?.[x-dx*j] === color) { count++; j++; }
                if(board[y-dy*j]?.[x-dx*j] !== null) blocked++;

                if (count >= 5) score += 100000;
                else if (count === 4) score += (blocked === 0) ? 10000 : 1000;
                else if (count === 3) score += (blocked === 0) ? 500 : 50;
                else if (count === 2 && blocked === 0) score += 10;
            });
            return score;
        }

        function getBasicGoMove() {
            let validMoves = [];
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(!board[y][x]) {
                        board[y][x] = 'white';
                        let myGroup = getGroup(y, x, 'white');
                        let liberties = getLiberties(myGroup);
                        board[y][x] = null;
                        if(liberties > 0) validMoves.push({y, x});
                    }
                }
            }
            if(validMoves.length > 0) {
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }
            return null;
        }

        // --- Rules ---
        function processOmok(y, x) {
            if (currentPlayer === 'black') {
                const r33 = document.getElementById('rule33').checked;
                const r44 = document.getElementById('rule44').checked;
                if (r33 && checkForbidden(y, x, 3)) { alert("3-3 Í∏àÏàò!"); return false; }
                if (r44 && checkForbidden(y, x, 4)) { alert("4-4 Í∏àÏàò!"); return false; }
            }
            board[y][x] = currentPlayer;
            return true;
        }
        function checkForbidden(y, x, k) {
            board[y][x] = 'black';
            let cnt = 0;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let c = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === 'black') { c++; i++; }
                let j=1; while(board[y-dy*j]?.[x-dx*j] === 'black') { c++; j++; }
                if(c === k) cnt++;
            }
            board[y][x] = null;
            return cnt >= 2;
        }
        function checkOmokWin(y, x) {
            const c = board[y][x];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let count = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === c) { count++; i++; }
                i=1; while(board[y-dy*i]?.[x-dx*i] === c) { count++; i++; }
                if(count >= 5) return true;
            }
            return false;
        }
        function processGo(y, x) {
            if (koPos && koPos.y === y && koPos.x === x) {
                if(playMode === 'hvh') alert("Ìå®(Ko)");
                return false;
            }
            const opponent = (currentPlayer === 'black') ? 'white' : 'black';
            board[y][x] = currentPlayer;
            let capturedStones = [];
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                const ny=y+dy, nx=x+dx;
                if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===opponent) {
                    const group = getGroup(ny, nx, opponent);
                    if(getLiberties(group) === 0) capturedStones.push(...group);
                }
            });
            const myGroup = getGroup(y, x, currentPlayer);
            if(capturedStones.length === 0 && getLiberties(myGroup) === 0) {
                board[y][x] = null;
                if(playMode === 'hvh') alert("ÏûêÏÇ¥Ïàò Í∏àÏßÄ");
                return false;
            }
            capturedStones.forEach(p => board[p.y][p.x] = null);
            captured[currentPlayer] += capturedStones.length;
            if (capturedStones.length === 1 && myGroup.length === 1 && getLiberties(myGroup) === 1) koPos = capturedStones[0];
            else koPos = null;
            return true;
        }
        function getGroup(y, x, color) {
            let g = [], visited = new Set(), stack = [{y, x}];
            visited.add(`${y},${x}`);
            while(stack.length) {
                let cur = stack.pop(); g.push(cur);
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=cur.y+dy, nx=cur.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===color && !visited.has(`${ny},${nx}`)) {
                        visited.add(`${ny},${nx}`); stack.push({y:ny, x:nx});
                    }
                });
            }
            return g;
        }
        function getLiberties(group) {
            let lib = new Set();
            group.forEach(p => {
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=p.y+dy, nx=p.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===null) lib.add(`${ny},${nx}`);
                });
            });
            return lib.size;
        }

        function undoMove() {
            if(historyStack.length === 0) return;
            let steps = (playMode === 'hva' && historyStack.length >= 2) ? 2 : 1;
            for(let i=0; i<steps; i++) {
                const prev = historyStack.pop();
                board = prev.board;
                currentPlayer = prev.currentPlayer;
                captured = prev.captured;
                koPos = prev.koPos;
            }
            isGameOver = false;
            let lastMove = historyStack.length > 0 ? historyStack[historyStack.length-1].move : {y:-1, x:-1};
            renderBoard(lastMove.y, lastMove.x);
            updateUI();
        }

        // --- Rendering Optimization (Flicker Fix) ---
        function renderBoard(lastY = -1, lastX = -1) {
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    const cell = document.getElementById(`cell-${y}-${x}`);
                    const stoneVal = board[y][x];
                    
                    // DOM ÏÉÅÌÉúÏôÄ JS ÏÉÅÌÉú ÎπÑÍµê (ÏµúÏ†ÅÌôî: Î≥ÄÍ≤ΩÎêú Í≤ÉÎßå Í∞±Ïã†)
                    const existingStone = cell.querySelector('.stone');
                    
                    if (stoneVal) {
                        // ÎèåÏù¥ ÏûàÏñ¥Ïïº ÌïòÎäîÎç∞...
                        if (!existingStone) {
                            // ÏóÜÏúºÎ©¥ ÏÉàÎ°ú ÎßåÎì¶
                            addStoneToCell(cell, stoneVal, y===lastY && x===lastX);
                        } else {
                            // ÏûàÎäîÎç∞ ÏÉâÏù¥ Îã§Î•¥Í±∞ÎÇò last ÎßàÏª§Í∞Ä Îã§Î•¥Î©¥ ÍµêÏ≤¥
                            const isBlack = existingStone.classList.contains('black');
                            const shouldBeBlack = (stoneVal === 'black');
                            const isLast = existingStone.classList.contains('last');
                            const shouldBeLast = (y===lastY && x===lastX);

                            if (isBlack !== shouldBeBlack || isLast !== shouldBeLast) {
                                cell.innerHTML = '';
                                addStoneToCell(cell, stoneVal, shouldBeLast);
                            }
                        }
                    } else {
                        // ÎèåÏù¥ ÏóÜÏñ¥Ïïº ÌïòÎäîÎç∞ ÏûàÏúºÎ©¥ ÏÇ≠Ï†ú
                        if (existingStone) cell.innerHTML = '';
                    }
                }
            }
        }

        function addStoneToCell(cell, color, isLast) {
            const s = document.createElement('div');
            s.className = `stone ${color}`;
            if (isLast) s.classList.add('last');
            cell.appendChild(s);
        }

        function updateUI() {
            playModeSelect.value = playMode;
            playMode = playModeSelect.value;
            turnText.innerText = `${currentPlayer === 'black' ? 'ÌùëÎèå' : 'Î∞±Îèå'} Ï∞®Î°Ä`;
            document.getElementById('cap-black').innerText = captured.white;
            const komi = parseFloat(komiInput.value) || 0;
            document.getElementById('cap-white').innerText = captured.black + komi;
        }

        function resetGame() { 
            playMode = playModeSelect.value;
            resetData(); 
        }

        function playSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            } catch(e) {}
        }

        window.onload = init;
    </script>
</body>
</html>
